\chapter{The control algorithm}
\label{ch:controlalgorithm} 
Unmanned aerial vehicles (UAVs) are a class of aircraft under the control of either a remote human pilot or a on board computer. UAVs were originally developed for military purposes, although recent advances in technologies, like Li-Ion batteries and brush-less motors, have brought this type of aircraft to  others scopes of usage, like commercial, scientific and also recreational.
Although most UAVs are fixed-wing aircraft, rotorcraft are becoming popular too due to the low price and ease of maintenance and run.\graffito{Quad-copter, more commonly referred to as \emph{drones}, are commercially available to a large amateur public.} The demand for this type of drone is increasing and the global market for commercial use is expected to grow in the next few years, thats why the study case is a low-level controller for helicopters, ducted-fan tail-sitters and multi-propeller helicopters.

\section{A novel approach to the copter control proble}
A common control strategy is a cascade feedback: an outer loop for the position and an inner loop for the attitude. The inner control loop is usually composed by 3 control loop for the roll, pitch and yaw attitude angles. While this is a easy and intuitive approach to the problem, a more advanced one can be developed: the rest of this chapter describes a novel approach as presented in \autocite{marconi}.

\section{Quaternions for rotations representation}
Although the attitude has 3 degrees of freedom\graffito{Rotations of 3D objects in a 3D world can be expressed by 3 scalar quantities, usually Euler angles or roll-pitch-yaw angles (RPY).}, any minimal parametrization suffers of singularity problems (or gimbals-look).\\
\graffito{A rotation matrix is a 3x3 orto-normal matrix, so although it is composed by 9 scalar values, the matrix itself has just 3 degrees of freedom}
A very common alternative representation is rotational matrices: those do not suffer of singularities problems but are quite  redundant since 9 scalar values are used to express just 3 degrees of freedom.\\
A good trade-off between compactness and ease of representation is archived with unit quaternions, a notation that allows to represent rotations in a compact form and with no gimbals-lock problems. Another advantage to consider is numerical stability: numerical drifts make both rotation matrices and unit quaternions loose their own properties: respectively being orthonormal and having module one; it is however way easier to scale a vector than force the orthonormal structure of a matrix. More details can be found in \autoref{ch:app:quaternions}.\\
Here it is highlighted than the general quaternion $q$ is given by:
\begin{equation} \label{eq:coptermodelmat}
\begin{split}
q := \begin{bmatrix}
\eta\\
\epsilon
\end{bmatrix}
\end{split}
\end{equation}
where $\eta$ is the \emph{real} component and $\epsilon$ is the \emph{pure imaginary} vector component of $q$ and the Hamilton product between 2 quaternion is indicated by the symbol $\oplus$.

\section{The copter model}
The dynamic model of the copter is given by:

\begin{equation} \label{eq:coptermodelmat}
\begin{split}
	M \ddot{p} &= -u_{f}Re_{3} + Mge_{3}\\
	\dot{R} &= RS(w)\\
	J\dot{w} &= S (Jw) w + u_{\tau}
\end{split}
\end{equation}

Where we call $ p $ the position vector of the center of gravity of the copter in the inertial reference frame $ \pazocal{F}_{i} $ and $ w $ the angular velocity of the vehicle in the body reference frame $ \pazocal{F}_{b} $. $ R $ is the rotation matrix representing the orientation of $ \pazocal{F}_{b} $ wrt $ \pazocal{F}_{i} $, $ J $ is the inertia matrix of the system and $ u_{f} $ and $ u_{\tau} $ are respectively the force and  the torque vector generated by the propellers.\graffito{Note that the while the $u_{f}$ is a scalar force which direction always aligned with the $z$ axis of $\pazocal{F}_{b}$, $u_{\tau}$ is a 3-dimensional vector.}
The $S(m)$ function generates a $3\times3$ matrix from vector $v$ such that the matrix product between $S(v)$ and another $3\times1$ vector $n$ correspond to the cross (vector) product between $m$ and $n$. $S$ can be constructed as:
\begin{equation} \label{eq:coptermodelmat}
\begin{split}
S(m) :&= \begin{bmatrix}
0 & -m_{3} & m_{2}\\
m_{3} & 0 & -m_{1}\\
-m_{2} & m_{1} & 0
\end{bmatrix}
\end{split}
\end{equation}

The copter model can be rewritten using quaternions to represent rotations by mean of the Rodriguez formula\cite{bib:rodriguez}:
\[ \pazocal{R}(q) = I + 2 \mu \pazocal{S}(\epsilon) + 2 \pazocal{S}(\epsilon)^{2}
 \]
as
\begin{equation} \label{eq:coptermodelquat}
\begin{split}
M \ddot{p} &= -u_{f}\pazocal{R}(q)e_{3} + Mge_{3}\\
\dot{q} &= \frac{1}{2} q \oplus \begin{bmatrix} 0 \\ w \end{bmatrix} \\
J\dot{w} &= S (Jw) w + u_{\tau}
\end{split}
\end{equation}



\section{Position control loop}
We can write the position error dynamic as:
\begin{equation} \label{eq:poserrdyn}
\begin{split}
M \ddot{\overline{p}} &= -u_{f}\pazocal{R}e_{3} + Mge_{3} - M\ddot{p}_{R}
\end{split}
\end{equation}
And define the control force as:
\begin{equation} \label{eq:ctrlforce}
\begin{split}
v^{c}_{R}(\ddot{p}_{R})&:=Mge_{3} - M\ddot{p}_{R}\\
v^{c}(\overline{p},\dot{\overline{p}},\ddot{p}_{R})&:=v^{c}_{R}(\ddot{p}_{R}) + \kappa(\overline{p},\dot{\overline{p}} )
\end{split}
\end{equation}
where $ \kappa(\overline{p},\dot{\overline{p}}) $ is a feedback action that can be computed as follow:
\begin{equation} \label{eq:feedback}
\begin{split}
\zeta_{1}&:=\overline{p}\\
\zeta_{2}&=\dot{\overline{p}} + \lambda_{1} \sigma (\frac{k_{1}}{\lambda_{1}}\lambda_{2})\\
\kappa(\overline{p},\dot{\overline{p}}) &:=\lambda_{2}\sigma(\frac{k_{2}}{\lambda{2}}\zeta_{2})
\end{split}
\end{equation}
where $k_{1}$, $k_{2}$, $\lambda_{1}$ and $\lambda_{2}$ are parameters to be tuned.\\
In \autoref{eq:ctrlforce} is mandatory to respect the constraint
\begin{equation} \label{eq:const}
\begin{split}
R_{R}e_{3} &= \frac{v^{c}_{R}(\ddot{p}_{R})}{\lVert v^{c}_{R}(\ddot{p}_{R})\rVert}
\end{split}
\end{equation}



The control scalar control force is than computed as:
\begin{equation} \label{eq:controlForce}
\begin{split}
u_{f} &:= \lVert v^{c}(\overline{p},\dot{\overline{p}},\ddot{p}_{R})\rVert
\end{split}
\end{equation}
\autoref{eq:ctrlforce} gives the total thrust the propeller should generate, however as already explained it is also necessary to compute the torque necessary to correct the vehicle attitude.\\
\autoref{sec:attControlLoop} will describe the attitude control low.

\section{Attitude control loop}\label{sec:attControlLoop}
The torque control vector is computed in a control loop nested into the position control loop, therefore, as usual in cascade control loops, it has a faster dynamic.
We start by defining the error attitude quaternion and the error angular velocity vector:
\begin{equation} \label{eq:qerr}
\begin{split}
\overline{q}&=q_{c}^{-1}\oplus q\\
\overline{w}:&=w-\overline{w}_{c}\\
\end{split}
\end{equation}
with
\begin{equation}
\begin{split}
\overline{w}_{c}:&=\pazocal{R}(\overline{q})^{T}w_{c}
\end{split}
\end{equation}
and $q_{c}$ computed as explained in \autoref{se:attSP}.

Then the control torque is given by:
\begin{equation}
\begin{split}
u_{\tau}&=u_{\tau}^{FF}(\overline{q},w_{c},\dot{w}_{c})   + u_{\tau}^{FB}(\overline{q},\overline{w},\overline{h})\\
u_{\tau}^{FF}(\overline{q},w_{c},\dot{w}_{c})   &=  J\pazocal{R}(\overline{q})^{T}\dot{w}_{c}   - S(J\overline{w}_{c}) \overline{w}_{c}\\
u_{\tau}^{FB}(\overline{q},\overline{w},\overline{h})   &=  -k_{p}\overline{h}\overline{\epsilon}  -k_{d}\overline{w}
\end{split}
\end{equation}
In the previous formula $k_{p}$ and $k_{d}$ are positive gains and $\overline{h} = \{-1,1\}$ is obtained by the hybrid function $\pazocal{H}_{c}$
\begin{equation}
\begin{split}
\pazocal{H}_{c} &= \begin{cases} \dot{\overline{h}} = 0  & \overline{h}\overline{\eta} \geq -\delta \\ \overline{h}^{+} \in \overline{sgn}(\overline{\eta}) & \overline{h}\overline{\eta} \leq -\delta  \end{cases}\\
\overline{sgn}(s) &= \begin{cases} sgn(s)  & \lvert s \rvert > 0 \\ \{-1,1\} &  s=0 \end{cases}\\
\end{split}
\end{equation}
$\eta \in (0,1)$ is the hysteresis threshold.\\

The control problem is more extensively explained in \autocite{marconi}, however the article does not specify how to compute the reference attitude $R_{R}$; this problem is addressed in the following section.


\section{Attitude set-point generation} \label{se:attSP}
The attitude reference orientation should be computed satisfying constraint \ref{eq:const}. The problem has just 1 degree of freedom which, for standard uses cases (i.e. for non acrobatic maneuver), is the vehicle yaw angle.\\
This thesis proposes an algorithm to compute the reference rotation matrix $R_{R}$ based on geometric projection. Considering the $yaw$ angle given, then the heading vector is defined as:
\begin{equation}
\begin{split}
d(yaw) &= [\cos{(yaw)} , \sin{(yaw)} , 0]^{T}
\end{split}
\end{equation}
The matrix $R_{R}$ is computed column-by-column as follows:
\begin{equation}
\begin{split}
R_{R}e_{3} :&= \frac{g e_{3} - \ddot{p}}{\lVert g e_{3} - \ddot{p} \rVert}\\
R_{R}e_{2} :&= \frac{R_{R}e_{3} \times d(yaw)}{\lVert R_{R}e_{3} \times d(yaw)  \rVert}\\
R_{R}e_{1} :&= \frac{R_{R}e_{2} \times R_{R}e_{3}}{\lVert R_{R}e_{2} \times R_{R}e_{3} \rVert}
\end{split}
\end{equation}
This technique allows to easily compute the reference rotation matrix that can be then easily converted to the quaternion rotation thanks to the Rodriguez formula.
The control attitude required in \autoref{eq:qerr} is then computed as follows:
\begin{equation}
\begin{split}
R_{c}e_{3} :&= \frac{v_{c} }{\lVert v_{c}  \rVert} \\
R_{c}e_{1} :&= \frac{R_{R}e_{1} \times R_{c}e_{3}}{\lVert R_{R}e_{1} \times R_{c}e_{3} \rVert}  \\
R_{c}e_{2} :&= \frac{R_{c}e_{3} \times R_{c}e_{1}}{\lVert R_{c}e_{3} \times R_{c}e_{1} \rVert}  
\end{split}
\end{equation}
end finally
\begin{equation}
\begin{split}
q_{c} &= \pazocal{R}^{-1}(R_{c})
\end{split}
\end{equation}
